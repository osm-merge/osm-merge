//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "fconfig.h"
#endif

#include <iostream>
#include <string>
#include <boost/program_options.hpp>
#include <boost/geometry.hpp>
#include <boost/json.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/core/core.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/file.hpp>
namespace logging = boost::log;
using namespace boost;
namespace opts = boost::program_options;

#include <osmium/index/map/dense_file_array.hpp>
#include <osmium/osm/object.hpp>
#include <osmium/handler/node_locations_for_ways.hpp>

#include "fastclip.hh"

int
main(int argc, char *argv[])
{
    opts::positional_options_description p;
    opts::variables_map vm;
    opts::options_description desc("Allowed options");

    logging::add_file_log("fastclip.log");
    try {
        // clang-format off
        desc.add_options()
            ("help,h", "display help")
            ("verbose,v", "Enable verbosity")
            ("infile,i", opts::value<std::string>(), "Input data file"
                        "The file to be processed")
            ("outfile,o", opts::value<std::string>(), "Output data file"
                "The output boundaries")
            ("filter,f", "Filter for only highways")
            ("boundary,b", opts::value<std::string>(), "Boundary data file"
             "The boundary MultiPolygon to use for clipping");
            // clang-format on
            opts::store(opts::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
        opts::notify(vm);
        if (argc == 1) {
            std::cout << "Usage: options_description [options]" << std::endl;
            std::cout << desc << std::endl;
            exit(0);
    }
        if (vm.count("help")) {
            std::cout << "Usage: options_description [options]" << std::endl;
            std::cout << desc << std::endl;
            exit(0);
        }
    } catch (std::exception &e) {
        std::cout << e.what() << std::endl;
        return 1;
    }

    opts::store(opts::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
    opts::notify(vm);

    // By default, write everything to the log file
    logging::core::get()->set_filter(
        logging::trivial::severity >= logging::trivial::debug
        );
    if (vm.count("verbose")) {
        // Enable also displaying to the terminal
        logging::add_console_log(std::cout, boost::log::keywords::format = ">> %Message%");
    }

    std::string outfile;
    std::string infile;
    auto fastclip = FastClip();

    if (vm.count("boundary")) {
        std::string filespec = vm["boundary"].as<std::string>();
        auto boundary = fastclip.readAOI(filespec);
        auto result = fastclip.make_geometry(boundary.as_object());
        // std::cout << boost::geometry::wkt(*result) << std::endl;
        switch(boundary.kind()) {
          case json::kind::object: {
              // std::cout  << "FIXME: OBJECT" << std::endl;
          }
          case json::kind::array: {
              // std::cout << "FIXME: ARRAY" << std::endl;
              auto const& arr = boundary.get_object();
          }
              // When reading in a GeoJson file containing a MultiPolygon,
              // the first objects and an array are just the headers from
              // the file. The actual data is in the string field.
          case json::kind::string: {
              // std::cout << "FIXME: STRING" << std::endl;
              auto const& obj = boundary.get_object();
              auto apoi = fastclip.make_geometry(obj);
          }
        }
    }

    if (vm.count("filter")) {
        if (vm.count("infile") && vm.count("outfile")) {
            infile = vm["infile"].as<std::string>();
            outfile = vm["outfile"].as<std::string>();
            fastclip.filterFile(infile, outfile);
        }
        exit(0);
    }

    // if (vm.count("outfile")) {
    //     outfile = vm["outfile"].as<std::string>();
    //     fastclip.writeOuters(outfile);
    //     BOOST_LOG_TRIVIAL(info) << "Wrote output file " << outfile;
    // }

    // const auto mem = location_index_pos->used_memory() + location_index_neg->used_memory();
    // m_vout << "About " << show_mbytes(mem) << " MBytes used for node location index (in main memory or on disk).\n";
    // show_memory_used();
    // m_vout << "Done.\n";

    // BOOST_LOG_TRIVIAL(warning) << "An informational warning message";
    // BOOST_LOG_TRIVIAL(error) << "An informational error message";
    // BOOST_LOG_TRIVIAL(debug) << "An informational debug message";

    BOOST_LOG_TRIVIAL(info) << "Wrote " << outfile;
}

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
