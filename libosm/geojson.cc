//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <boost/log/trivial.hpp>
#include <boost/geometry.hpp>
#include <boost/json.hpp>
using namespace boost;
namespace json = boost::json;
#include <cstdio>

#include "geojson.hh"
#include "osmobjects.hh"
using namespace osmobjects;

long int OsmObject::newid = -1;

namespace geojson {


  bool
  GeoJson::makeFeature(const json::value &val) {
    std::vector<point_t> points;

    auto ftype = val.at("type");
    auto props = val.at("properties");
    auto geom = val.at("geometry");
    auto gtype = geom.at("type");
    auto coords = geom.at("coordinates");

    // Add to the cache
    if (gtype == "Point") {
      auto node = std::make_shared<OsmNode>();
      node_cache[node->id] = *node;
    } else {
      auto way = std::make_shared<OsmWay>();
      for( const key_value_pair& kv: props.get_object() ) {
        auto foo = kv.value().as_string();
        std::string fixed = foo.c_str();
        boost::algorithm::replace_all(fixed, "\"", "");
        // boost::algorithm::replace_all(fixed, "\'", "");
        boost::algorithm::replace_all(fixed, "&", "&amp;");
        way->addTag(kv.key(), fixed);
      }
      way->id = OsmObject::newid--;
      if (coords.is_array()) {
        auto array = coords.get_array();
        for (auto it = array.begin(); it!= array.end(); ++it) {
          double lat = it->at(0).as_double();
          double lon = it->at(1).as_double();
          point_t point(lat, lon);
          points.push_back(point);
          auto node = OsmNode();
          node.id = OsmObject::newid--;
          node.version = 1;
          way->addRef(node.id);
          node_cache[node.id] = node;
        }
        if (gtype == "LineString") {
          boost::geometry::assign_points(way->linestring, points);
        } else {
          boost::geometry::assign_points(way->polygon, points);
        }
        way->version = 1;
        way->id = OsmObject::newid--;
        way_cache[way->id] = way;
      }
    }

    return true;
  }

#ifdef SAX
  // CPLSetConfigOption( "OGR_GEOJSON_MAX_OBJ_SIZE", "0" );
  json::value
  readFile(const std::string &filespec) {
    auto foo = GeoJson();
    FILE *fp = std::fopen(filespec.c_str(), "r");
    char buffer[500];
    size_t         ret;
    boost::system::error_code ec;
    // int elements = 0;
    do {
      ret = std::fread(buffer, 1, 500, fp);
      // for (auto it = std::begin(buffer); it != std::end(buffer); ++it) {
      //   if (it == "<") {
      //     if (elements == 0) {
      //       elements = 1;
      //     } else {
      //       elements += 1;
      //     }
      //   }
      //   if (it == ">") {
      //     elements -= 1;
      //   }
      //   // A complete JSON entry has been read
      //   if (elements == 0) {
      std::cerr << buffer;
      foo.write(buffer, ret, ec );
      // foo.write_some(false,buffer, ret, ec);
    } while (! std::feof(fp));

    json::value result;
    return result;
  }
#else
  json::value
  GeoJson::readFile(const std::string &filespec) {
    json::stream_parser p;
    boost::system::error_code ec;
    auto f = std::fopen(filespec.c_str(), "r");
    do {
      char buf[4096];
      auto const nread = std::fread( buf, 1, sizeof(buf), f );
      p.write( buf, nread, ec );
    }
    while( ! feof(f) );
    std::fclose(f);
    return p.release();
  }
#endif
} // end of geojson namespace

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
