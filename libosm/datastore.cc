//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     This project is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <fstream>
#include <filesystem>
#include <boost/format.hpp>

#include "datastore.hh"

namespace datastore {

  void
  DataStore::openOutfiles(const std::string &format) {
    for (auto it = aoi.begin(); it != aoi.end(); ++it) {
      std::string outfile;
      if (it->second->containsKey("task")) {
	outfile = format +  it->second->getTag("task");
	boost::algorithm::replace_all(outfile, " ", "_");
      } else if (it->second->containsKey("name")) {
	outfile = format +  it->second->getTag("name");
      } else {
	outfile = format;
      }
      std::ofstream out(outfile);
      outfiles[outfile] = std::make_shared<std::ofstream>(outfile);
    }
  }

  /// Make this the AOI for the next input file
  void
  DataStore::addAOI(const std::string &filespec) {
    // aoi = way_cache;
  }

  void
  DataStore::writeData(const std::string &outfile) {
    std::ofstream out(outfile);
    std::filesystem::path path(outfile);
    if (path.extension() == ".osm") {
      out << "<?xml version='1.0' encoding='UTF-8'?>" << std::endl;
      out << "<osm version=\"0.6\" generator=\"osm-merge\">" << std::endl;
      for (auto it = std::begin(node_cache); it != std::end(node_cache); ++it) {
	out << "  " << *it->second.as_osmxml() << std::endl;
      }
      for (auto it = std::begin(way_cache); it != std::end(way_cache); ++it) {
	out << "  " << *it->second->as_osmxml() << std::endl;
      }
      out << "</osm>" << std::endl;
    } else if (path.extension() == ".geojson") {
      for (auto it = std::begin(node_cache); it != std::end(node_cache); ++it) {
	out << "  " << *it->second.as_geojson() << std::endl;
      }
      for (auto it = std::begin(way_cache); it != std::end(way_cache); ++it) {
	out << "  " << *it->second->as_geojson() << std::endl;
      }
    }
    out.close();
  }

} // end of datastore

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
