//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     This project is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <fstream>
#include <filesystem>
#include <boost/format.hpp>

#include "datastore.hh"

namespace datastore {

  void
  DataStore::openOutfiles(const std::string &format) {
    std::filesystem::path path(format);
    int task = 0;
    for (auto it : aoi) {
      auto outfile = boost::format(format) % task++ % suffix;
      struct outfiles ofile;
      ofile.file = std::fopen(outfile.str().c_str(), "w");
      std::cerr  << outfile << std::endl;
      ofile.boundary = it;
      output.push_back(ofile);
    }
  }

  /// Make this the AOI for the next input file
  void
  DataStore::addAOI(const multipolygon_t &mpoly) {
    aoi = mpoly;
    openOutfiles("Task_%1%.%2%");
  }

  void
  DataStore::writeData(const std::string &outfile) {
    std::ofstream out(outfile);
    std::filesystem::path path(outfile);
    if (path.extension() == ".osm") {
      out << "<?xml version='1.0' encoding='UTF-8'?>" << std::endl;
      out << "<osm version=\"0.6\" generator=\"osm-merge\">" << std::endl;
      for (auto it : node_cache) {
	out << "  " << it.second.as_osmxml() << std::endl;
      }
      for (auto it : way_cache) {
	out << "  " << it.second->as_osmxml() << std::endl;
      }
      out << "</osm>" << std::endl;
    } else if (path.extension() == ".geojson") {
      for (auto it : node_cache) {
	out << "  " << it.second.as_geojson() << std::endl;
      }
      for (auto it : way_cache) {
	out << "  " << it.second->as_geojson() << std::endl;
      }
    }
    out.close();
  }

} // end of datastore

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
