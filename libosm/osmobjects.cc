//
// Copyright (c) 2024, 2025 OpenStreetMap US
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <iostream>
#include <boost/log/trivial.hpp>
#include <libxml++/libxml++.h>
#include <boost/date_time.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;
#define BOOST_BIND_GLOBAL_PLACEHOLDERS 1

#include "osmobjects.hh"

namespace osmobjects {

void
OsmObject::dump(void) const
{
   BOOST_LOG_TRIVIAL(debug) << "Dumping OsmObject()";
    if (action == create) {
       BOOST_LOG_TRIVIAL(debug) << "\tAction: Create";
    } else if (action == modify) {
       BOOST_LOG_TRIVIAL(debug) << "\tAction: Modify";
    } else if (action == remove) {
       BOOST_LOG_TRIVIAL(debug) << "\tAction: Delete";
    }

    if (type == node) {
       BOOST_LOG_TRIVIAL(debug) << "\tType: OsmNode";
    } else if (type == way) {
       BOOST_LOG_TRIVIAL(debug) << "\tType: OsmWay";
    } else if (type == relation) {
       BOOST_LOG_TRIVIAL(debug) << "\tType: OsmRelation";
    }
   BOOST_LOG_TRIVIAL(debug) << "\tID: " << std::to_string(id);
   BOOST_LOG_TRIVIAL(debug) << "\tVersion: " << std::to_string(version);
   BOOST_LOG_TRIVIAL(debug) << "\tTimestamp: " << to_simple_string(timestamp);
   if (uid > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tUID: " << std::to_string(uid);
   }

   if (user.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tUser: " << user;
   }
   if (changeset > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tChange ID: " << std::to_string(changeset);
   }
#if 0
    if (attributes.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tAttributes: " << attributes.size();
        for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
           BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->first << ": " << it->second;
        }
    }
#endif
    if (tags.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tTags: " << tags.size();
        for (auto it = std::begin(tags); it != std::end(tags); ++it) {
           BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->first << ": " << it->second;
        }
    }
};

void
OsmWay::dump(void) const
{
    OsmObject::dump();
    if (refs.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tRefs: " << refs.size();
        std::string tmp;
        for (auto it = std::begin(refs); it != std::end(refs); ++it) {
            tmp += std::to_string(*it) + ", ";
        }
        tmp.pop_back();
        tmp.pop_back();
       BOOST_LOG_TRIVIAL(debug) << "\t" << tmp;
    }
   BOOST_LOG_TRIVIAL(debug) << boost::geometry::wkt(linestring);
   BOOST_LOG_TRIVIAL(debug) << boost::geometry::wkt(polygon);
    if (tags.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tTags: " << tags.size();
        for (auto const& [key, val] : tags)
        {
           BOOST_LOG_TRIVIAL(debug) << key
                    << ':'
                    << val
                    << ", ";
        }
       BOOST_LOG_TRIVIAL(debug);
    } else {
       BOOST_LOG_TRIVIAL(debug) << "No tags.";
    }
};

void
OsmRelation::dump() const
{
    OsmObject::dump();
    if (members.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tMembers: " << members.size();
        std::string tmp;
        for (const auto &member: std::as_const(members)) {
            member.dump();
        }
       BOOST_LOG_TRIVIAL(debug) << "\t" << tmp;
    }
}

void
OsmRelationMember::dump() const
{
   BOOST_LOG_TRIVIAL(debug) << "\t\tDumping Relation member";
   BOOST_LOG_TRIVIAL(debug) << "\t\t\tRef: " << ref;
    if (type == node) {
       BOOST_LOG_TRIVIAL(debug) << "\t\t\tType: OsmNode";
    } else if (type == way) {
       BOOST_LOG_TRIVIAL(debug) << "\t\t\tType: OsmWay";
    } else if (type == relation) {
       BOOST_LOG_TRIVIAL(debug) << "\t\t\tType: OsmRelation";
    }
   BOOST_LOG_TRIVIAL(debug) << "\t\t\tRole: " << role;
}

int
OsmNode::getZ_order() const
{
    return z_order;
}

void
OsmNode::setZ_order(int newZ_order)
{
    z_order = newZ_order;
}

} // namespace osmobjects
