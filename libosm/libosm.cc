//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <iostream>
#include <algorithm>
#include "libosm.hh"
using namespace osmobjects;

// Called by libxml++ for each element of the XML file
void
XML_Parser::on_start_element(const Glib::ustring &name,
                             const AttributeList &attributes)
{
    // BOOST_LOG_TRIVIAL(debug) << "::on_start_element() called: " << name;
    if (name == "node") {
        // Nodes are easy, everything is in the attributes.
        long int id = 0;
        float lat = 0.0, lon = 0.0;
        int version = 0;
        auto node = osmobjects::OsmNode();
        for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
            // BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
            if (it->name == "id") {
                id = std::stol(it->value);
                node.id = id ;
            }
            if (it->name == "lat") {
                lat = std::stod(it->value);
            }
            if (it->name == "lon") {
                lon = std::stod(it->value);
            }
            if (it->name == "version") {
                version = std::stoi(it->value);
                node.version = version;
            }
            if (it->name == "timestamp") {
                // The trailing Z needs to be dropped to be an ISO string
                std::string foo = it->value.substr(0, 16);
                node.timestamp = boost::posix_time::from_iso_extended_string(foo);
            }
        }
        node.setPoint(lat, lon);
        node_cache[id] = node;
        // node.dump();
    } else if (name == "relation") {
        BOOST_LOG_TRIVIAL(debug) << "\t\tFIXME";
    } else if (name == "way") {
        auto way = osmobjects::OsmWay();
        long int id = 0;
        for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
            BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
            for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
                // BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
                if (it->name == "id") {
                    long int id = std::stol(it->value);
                    way.id = id ;
                }
                if (it->name == "version") {
                    int version = std::stoi(it->value);
                    way.version = version;
                }
                if (it->name == "timestamp") {
                    // The trailing Z needs to be dropped to be an ISO string
                    std::string foo = it->value.substr(0, 16);
                    way.timestamp = boost::posix_time::from_iso_extended_string(foo);
                }
            }
        }
        way_cache[id] = way;
        way.dump();
    } else if (name == "nd") {
        for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
            BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
        }
    } else if (name == "tag") {
        for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
            BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
        }
    }
}

void
XML_Parser::on_end_element(const Glib::ustring& name)
{
    if (name != "node") {
        BOOST_LOG_TRIVIAL(debug) << "::on_end_element() called: " << name;
    }
}

// void
// XML_Parser::on_characters(const Glib::ustring& text)
// {
//   BOOST_LOG_TRIVIAL(debug) << "on_characters(): " << text;
// }

void
XML_Parser::on_comment(const Glib::ustring& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_comment(): " << text;
}

void
XML_Parser::on_warning(const Glib::ustring& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_warning(): " << text;
}
void
XML_Parser::on_error(const Glib::ustring& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_error(): " << text;
}

void
XML_Parser::on_fatal_error(const Glib::ustring& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_fatal_error(): " << text;
}

// void
// XML_Parser::on_cdata_block(const Glib::ustring& text)
// {
//   BOOST_LOG_TRIVIAL(debug) << "on_cdata_block(): " << text;
// }

bool
XML_Parser::readXML(std::istream &xml)
{
 #ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("XML_Parser::readXML: took %w seconds\n");
#endif

    setlocale(LC_NUMERIC, "C");
    std::ofstream myfile;

    // libxml calls on_element_start for each node, using a SAX parser,
    // and works well for large files.
    try {
        set_substitute_entities(true);
        parse_stream(xml);
    } catch (const xmlpp::exception &ex) {
        // FIXME: files downloaded seem to be missing a trailing \n,
        // so produce an error, but we can ignore this as the file is
        // processed correctly.
        BOOST_LOG_TRIVIAL(error) << "libxml++ exception: " << ex.what();
        // log_debug(xml.rdbuf());
        int return_code = EXIT_FAILURE;
    }

    return true;
}

void
PBF_Parser::node_callback(uint64_t /*osmid*/,
                          double /*lon*/,
                          double /*lat*/,
                          const Tags &/*tags*/) {
    BOOST_LOG_TRIVIAL(debug) << "PBF_Parser::node_callback() called";
}

void
PBF_Parser::way_callback(uint64_t /*osmid*/,
                         const Tags &/*tags*/,
                         const std::vector<uint64_t> &/*refs*/) {
    BOOST_LOG_TRIVIAL(debug) << "PBF_Parser::way_callback() called";
}

void
PBF_Parser::relation_callback(uint64_t /*osmid*/,
                              const Tags &/*tags*/,
                              const References & /*refs*/) {
    BOOST_LOG_TRIVIAL(debug) << "PBF_Parser::relation_callback() called";
}


