//
// Copyright (c) 2024, 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is derived from osmium-tools, thanks you Jochen Topf for using
// the GPLv3! The osmium command tools are great, but I wanted something
// that could clip data and filter it focused on highways.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "fconfig.h"
#endif

// #include <sstream>
#include <filesystem>
#include <unistd.h>
#include <stdio.h>
namespace fs = std::filesystem;

#include <boost/geometry.hpp>
#include <boost/log/trivial.hpp>
#include <boost/json.hpp>
using namespace boost;
namespace logging = boost::log;
namespace json = boost::json;

#include <osmium/handler/node_locations_for_ways.hpp>
#include <osmium/index/map/dense_file_array.hpp>
#include <osmium/geom/ogr.hpp>
#include <osmium/area/multipolygon_manager.hpp>

#include <osmium/io/any_output.hpp>
#include <osmium/index/nwr_array.hpp>
#include <osmium/index/id_set.hpp>

#include "fastclip.hh"

// using index_type = osmium::index::map::SparseFileArray<osmium::unsigned_object_id_type, osmium::Location>;

// struct MyHandler : public osmium::handler::Handler {

//     // The callback functions can be either static or not depending on whether
//     // you need to access any member variables of the handler.
//     static void way(const osmium::Way& way) {
//         std::cout << "way " << way.id() << "\n";
//         for (const auto& nr : way.nodes()) {
//             std::cout << "  node " << nr.ref() << " " << nr.location() << "\n";
//         }
//     }

// }; // struct MyHandler

std::string
FastClip::check_index_type(const std::string& index_type_name) {
    std::string type{index_type_name};
    const auto pos = type.find(',');
    if (pos != std::string::npos) {
        type.resize(pos);
    }

    // const auto& map_factory = osmium::index::MapFactory<osmium::unsigned_object_id_type, osmium::Location>::instance();

    return index_type_name;
}

// void find_member_nodes(std::string filespec) {
//     osmium::io::Reader reader{filespec, osmium::osm_entity_bits::relation, osmium::io::read_meta::no};
//     while (osmium::memory::Buffer buffer = reader.read()) {
//         for (const auto& relation : buffer.select<osmium::Relation>()) {
//             for (const auto& member : relation.members()) {
//                 if (member.type() == osmium::item_type::node) {
//                     m_member_node_ids.set(member.positive_ref());
//                 }
//             }
//         }
//     }
//     m_member_node_ids.sort_unique();
// };

void
FastClip::add_filter(osmium::osm_entity_bits::type entities,
                     const osmium::TagMatcher& matcher) {
    if (entities & osmium::osm_entity_bits::node) {
        m_filters(osmium::item_type::node).add_rule(true, matcher);
    }
    if (entities & osmium::osm_entity_bits::way) {
        m_filters(osmium::item_type::way).add_rule(true, matcher);
    }
    if (entities & osmium::osm_entity_bits::relation) {
        m_filters(osmium::item_type::relation).add_rule(true, matcher);
    }
}

bool
FastClip::display_progress() const {
    // m_display_progress = display_progress_type::on_tty;
    // switch (m_display_progress) {
    //   case display_progress_type::on_tty:
    //       return osmium::util::isatty(2); // if STDERR is a TTY
    //   case display_progress_type::always:
    //       return true;
    //   default:
    //       break;
    // }
    // return false;
    return osmium::util::isatty(2);
}

void
FastClip::add_nodes(const osmium::Way& way) {
    for (const auto& nr : way.nodes()) {
        m_ids(osmium::item_type::node).set(nr.positive_ref());
    }
}

void
FastClip::copy_data(osmium::ProgressBar& progress_bar,
                    osmium::io::Reader& reader,
                    osmium::io::Writer& writer,
                    location_handler_type& location_handler) {
    while (osmium::memory::Buffer buffer = reader.read()) {
        progress_bar.update(reader.offset());
        osmium::apply(buffer, location_handler);

        if (true) {
            writer(std::move(buffer));
        } else {
            for (const auto& object : buffer) {
                if (object.type() != osmium::item_type::node || !static_cast<const osmium::Node&>(object).tags().empty()) {
                    writer(object);
                }
            }
        }
    }
}

std::shared_ptr<multipolygon_t>
FastClip::make_geometry(const std::string &wkt) {
    // Convert a WKT string into a geometry
    auto geom = boost::geometry::from_wkt<multipolygon_t>(wkt);
    auto mpoly = std::make_shared<multipolygon_t>(geom);

    return mpoly;
}

std::shared_ptr<multipolygon_t>
FastClip::make_geometry(const json::object &obj) {
    auto mpoly = std::make_shared<multipolygon_t>();
    std::cout << "Object has " << obj.size() << " entries" << std::endl;
    if (obj.empty()) {
      BOOST_LOG_TRIVIAL(error) << "Object has no entries!";
      return mpoly;
    }
    auto data = json::parse(json::serialize(obj));
    auto foo = data.at("features");
    auto features = foo.get_array();
    // BOOST_LOG_TRIVIAL(debug) << "DEBUG: " << features;
    for (auto it = features.begin(); it!= features.end(); ++it) {
        // BOOST_LOG_TRIVIAL(debug) << it;
      // FIXME: so far all types have been a Feature
      // auto &type = it->at("type");
      // std::cout << "TYPE " << type << std::endl;
      auto &geom = it->at("geometry");
      auto &props = it->at("properties");
      // auto &gtype = props.at("type");
      // std::cout << "GEOM TYPE " << gtype << std::endl;
      auto &coords = geom.at("coordinates");//
      std::cout << "PROPS " << props << std::endl;
      // std::cout << "GEOM " << std::setprecision(7) << std::fixed << geom << std::endl;

      polygon_t poly;
      std::vector<point_t> points;

      auto foobar = coords.get_array();
      for (auto itt = foobar.begin(); itt!= foobar.end(); ++itt) {
        // std::cout << std::setprecision(7) << std::fixed << "COORDS:  " << *itt << std::endl;
        auto &foo = itt->as_array();
        // FIXME: it's probably an inner multipolygon, so drop it
        if (foo.at(0).is_array()) {
            auto bar = foo.at(0).get_array();
            for (auto iitt = bar.begin(); iitt!= bar.end(); ++iitt) {
                try {
                    std::cout << "BARBY " << *iitt << std::endl;
                    double lat = bar.at(0).as_double();
                    double lon = bar.at(1).as_double();
                    point_t point(lat, lon);
                    points.push_back(point);
                } catch (std::exception &e) {
                    std::cout << "FOO1 " << foo << std::endl;
                }
                boost::geometry::assign_points(poly, points);
                continue;
            }
        }
        try {
            double lat = foo.at(0).as_double();
            double lon = foo.at(1).as_double();
            point_t point(lat, lon);
            points.push_back(point);
        } catch (std::exception &e) {
            std::cout << "FOO2 " << foo << std::endl;
        }
      }
      boost::geometry::assign_points(poly, points);
    }
#if 0
    if (obj.is_array()) {
      auto toplevel = obj.get_array();
      for (auto it = toplevel.begin(); it!= toplevel.end(); ++it) {
        auto &type = it->at("type");
        auto &geom = it->at("geometry");
        auto &props = it->at("properties");
        // auto &gtype = props.at("type");
        // auto &coords = geom.at("coordinates");
        // std::cout << "TYPE " << type << std::endl;
        // std::cout << "GEOM TYPE " << gtype << std::endl;
        // std::cout << "GEOM " << coords << std::endl;
        std::cout << "PROPS " << props << std::endl;
        // try {
        //   std::cout << "NAME2 " << props.at("name") << std::endl;
        // } catch (std::exception &e) {
        //   std::cerr << e.what() << std::endl;
        // }
        if (it->is_array()) {
          std::cout  << "BARFUR: " << it->get_array() << std::endl;
        }
      }
    }
    // std::string furbar = boost::json::serialize(coords);
    // boost::replace_all(furbar, "[", "");
    // boost::replace_all(furbar, "]", "");
    // boost::replace_all(furbar, ",", ", "); // FIXME: easir to read
    // const double aarrgg[][2] = {*furbar.c_str()};
    // std::cout  << "FURBAR: " << *aarrgg << std::endl;
    // multipolygon_t mpoly = {furbar};
    // std::cout  << "FURBAR: " << coords.is_array() << std::endl;
    // if (coords.is_array()) {
    //   std::cout  << "COORDS is array" << std::endl;
    //   auto &xxx = coords.get_array();
    //   for (auto itt = xxx.begin(); itt!= xxx.end(); ++itt) {
    //       std::cout  << "XXX " << *itt << std::endl;
    //   }
    // }
    // auto &xxx = coords.get_array();
    // for (auto itt = xxx.begin(); itt!= xxx.end(); ++itt) {
    //     std::cout << "NO9! " << *itt << std::endl;
    //     auto &yyy = itt->get_array();
    //     for (auto iitt = yyy.begin(); iitt!= yyy.end(); ++iitt) {
    //         // std::cout << "NO10! " << iitt->is_array() << std::endl;
    //         std::cout << "FOO: " << *iitt << std::endl;
    //         auto &zzz = iitt->get_array();
    //         for (auto iitt2 = zzz.begin(); iitt2!= zzz.end(); ++iitt2) {
    //             // std::cout << "NO11! " << iitt2->is_array() << std::endl;
    //             std::cout << "NO12! " << std::setprecision(7) << std::fixed << iitt2->at(0).as_double() << " : " << iitt2->at(1).as_double() << std::endl;
    //              // auto &aaa = iitt2->get_array();
    //              // for (auto iitt3 = aaa.begin(); iitt3!= aaa.end(); ++iitt3) {
    //              //     std::cout << "NO13! " << std::setprecision(15) << iitt3->as_double() * 1.0  << std::endl;
    //              // }
    //         }
#endif

    return mpoly;
}

bool
FastClip::filterFile(const std::string &infile,
                    const std::string &outfile) {
        // Filter anything not a highway.
        std::filesystem::path datafile = infile;
        if (!std::filesystem::exists(datafile)) {
            BOOST_LOG_TRIVIAL(error) << "File not found: " << datafile;
            return false;
        }

        std::string informat = std::filesystem::path(infile).extension();
        std::string outformat = std::filesystem::path(outfile).extension();
        
        const osmium::io::File input_file{infile, informat};
        const osmium::io::File output_file{outfile, outformat};

        
        // tell it to only read nodes and ways.
        osmium::io::Reader reader{infile, osmium::osm_entity_bits::way};
        osmium::io::Header header = reader.header();
        header.set("generator", "fastclip");
        osmium::io::Writer writer{outfile, header,
            osmium::io::overwrite::allow};

        osmium::TagsFilter hfilter{false};
        hfilter.add_rule(true, "highway", "path");
        hfilter.add_rule(true, "highway", "footway");
        hfilter.add_rule(true, "highway", "track");
        hfilter.add_rule(true, "highway", "unclassified");
        hfilter.add_rule(true, "highway", "residential");
        hfilter.add_rule(true, "highway", "tertiary");
        hfilter.add_rule(true, "highway", "primary");
        hfilter.add_rule(true, "highway", "secondary");

        // Get all ways matching the highway filter
        osmium::ProgressBar progress_bar1{reader.file_size(), display_progress()};
        while (osmium::memory::Buffer buffer = reader.read()) {
            progress_bar1.update(reader.offset());
            // for (const auto& object : buffer.select<osmium::OSMObject>()) {
            for (const auto& way : buffer.select<osmium::Way>()) {
                if (osmium::tags::match_any_of(way.tags(), hfilter)) {
                    // Cache the node refs
                    add_nodes(way);
                    writer(way);
                }
            }
        }
        // writer.close();
        // FIXME: I'm not sure if we can reuse the reader
        // reader.close();
        progress_bar1.done();

        std::string pos_name = "dense_file_array";
        std::string neg_name = "dense_file_array";

        // Now get the nodes that are referenced by the ways.
        osmium::ProgressBar progress_bar2{reader.file_size(), display_progress()};
        const auto& map_factory = osmium::index::MapFactory<osmium::unsigned_object_id_type, osmium::Location>::instance();
        auto location_index_pos = map_factory.create_map(pos_name);
        auto location_index_neg = map_factory.create_map(neg_name);
#if 1
        index_type index;
        location_handler_type location_handler{index};
        // location_handler_type location_handler{*location_index_pos, *location_index_neg};

        // std::string default_index_type{ map_factory.has_map_type("sparse_mmap_array") ? "sparse_mmap_array" : "sparse_mem_array" };

        // osmium::io::Reader reader2{"foobar.osm", osmium::osm_entity_bits::way};
        // const int fd = ::open(infile.c_str(), O_RDWR);
        const int fd = ::open(infile.c_str(), O_RDWR);
        if (fd == -1) {
            BOOST_LOG_TRIVIAL(error) << "Can not open location cache file '" << infile << "': " << std::strerror(errno);
            return 1;
        }

        // osmium::io::Reader reader{m_input_files[0]};
        // osmium::io::Header header{reader.header()};
        // setup_header(header);
        osmium::ProgressBar progress_bar{reader.file_size(), display_progress()};
        copy_data(progress_bar, reader, writer, location_handler);
        progress_bar.done();

        writer.close();
        reader.close();
#endif
#if 0
            osmium::io::Reader nreader{outfile, osmium::osm_entity_bits::node};
            while (osmium::memory::Buffer buffer = nreader.read()) {
                progress_bar2.update(nreader.offset());
                for (const auto& object : buffer.select<osmium::OSMObject>()) {
                    if (m_ids(object.type()).get(object.positive_id())) {
                        writer(object);
                    }
                }
            }
            progress_bar2.done();
#endif
#if 0
            BOOST_LOG_TRIVIAL(debug) << "Copying input file '" << infile << "'\n";
            osmium::io::Reader reader{infile};
            osmium::io::Header header{reader.header()};
            setup_header(header);
            
            osmium::ProgressBar progress_bar{reader.file_size(), display_progress()};
            copy_data(progress_bar2, reader, writer, location_handler);
            progress_bar2.done();

#endif
            writer.close();
            reader.close();
            BOOST_LOG_TRIVIAL(info) << "Wrote " << outfile;

        return true;
    };

#if 0
bool
FastClip::writeOuters(const std::string &filespec) {
    BOOST_LOG_TRIVIAL(debug) << "There are " <<  outers.size() << " outer boundaries" ;
    // Set the SRS to avoid problems later.
    OGRSpatialReference* poSRS = new OGRSpatialReference();
    poSRS->importFromEPSG(4326);
    GDALDriver *driver = (GDALDriver *)GDALGetDriverByName("GeoJson");
    // auto poDS = (GDALDataset*) GDALOpenEx( "point.geojson", GDAL_OF_VECTOR, NULL, NULL, NULL );
    fs::path foo(filespec);
    // GDAL can't overwrite GeoJson files.
    if (std::filesystem::exists(filespec)) {
        std::filesystem::remove(filespec);
    }
    GDALDataset *poDS = driver->Create(filespec.c_str(), 0, 0, 0, GDT_Unknown, NULL );
    auto layer = poDS->CreateLayer( "boundaries", NULL, wkbMultiPolygon, NULL );
    // The only field is the
    OGRFieldDefn oField("Name", OFTString);
    oField.SetWidth(128);
    layer->CreateField(&oField);
    // Each entry
    for (auto it = outers.begin(); it!= outers.end(); ++it) {
        OGRFeature *feature = OGRFeature::CreateFeature(layer->GetLayerDefn());
        feature->SetField("name", it->first.c_str());
        int result = layer->CreateFeature(feature);
        // BOOST_LOG_TRIVIAL(debug) << "Regions: " << it->second.getGeometryName();
        // feature->SetSpatialRef(poSRS);
        // Clean to avoid memory leaks
        OGRFeature::DestroyFeature(feature);
    }
    // Clean to avoid memory leaks
    poSRS->Release();
    poDS->Close();
    return true;
}
#endif

// CPLSetConfigOption( "OGR_GEOJSON_MAX_OBJ_SIZE", "0" );
json::value
FastClip::readAOI(const std::string &filespec) {
    json::stream_parser p;
    boost::system::error_code ec;
    auto f = std::fopen(filespec.c_str(), "r");
    do {
        char buf[4096];
        auto const nread = std::fread( buf, 1, sizeof(buf), f );
        p.write( buf, nread, ec );
    }
    while( ! feof(f) );
    std::fclose(f);
    return p.release();
}

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
