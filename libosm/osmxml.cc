//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <iostream>
#include <algorithm>
#include <filesystem>

#include "osmobjects.hh"
using namespace osmobjects;
#include "osmxml.hh"

namespace osmxml {

// Called by libxml++ for each element of the XML file
void
XML_Parser::on_start_element(const std::string &name,
                             const AttributeList &attributes)
{
  // BOOST_LOG_TRIVIAL(debug) << "::on_start_element() called: " << name;
  if (name == "osm" || name == "bounds") {
    return;
  }

  if (name == "node") {
    // Nodes are easy, everything is in the attributes.
    long int id = 0;
    float lat = 0.0, lon = 0.0;
    int version = 0;
    auto node = osmobjects::OsmNode();
    for (auto it : attributes) {
      // BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
      if (it.name == "id") {
        id = std::stol(it.value);
        node.id = id ;
      }
      if (it.name == "lat") {
        lat = std::stod(it.value);
      }
      if (it.name == "lon") {
        lon = std::stod(it.value);
      }
      if (it.name == "version") {
        version = std::stoi(it.value);
        node.version = version;
      }
      if (it.name == "timestamp") {
        // The trailing Z needs to be dropped to be an ISO string
        std::string fixed = it.value.substr(0, 16);
        node.timestamp = boost::posix_time::from_iso_extended_string(fixed);
        node.timestring = it.value;
      }
    }
    node.setPoint(lat, lon);
    BOOST_LOG_TRIVIAL(debug) << *node.as_osmxml();
    node_cache[id] = node;
  } else if (name == "relation") {
    BOOST_LOG_TRIVIAL(debug) << "\t\tFIXME: relations";
  } else if (name == "way") {
    way = std::make_shared<OsmWay>();
    long int id = 0;
    for (auto it : attributes) {
      // BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->name << ": " << it->value;
      if (it.name == "id") {
        long int id = std::stol(it.value);
        way->id = id ;
      }
      if (it.name == "version") {
        int version = std::stoi(it.value);
        way->version = version;
      }
      if (it.name == "timestamp") {
        // The trailing Z needs to be dropped to be an ISO string
        std::string fixed = it.value.substr(0, 16);
        way->timestamp = boost::posix_time::from_iso_extended_string(fixed);
        way->timestring = it.value;
      }
    }
  } else if (name == "nd") {
    // there is only  a single attribute, which is the ref value
    way->addRef(std::stol(attributes.at(0).value));
  } else if (name == "tag") {
    // If way isn't set, it's a tag on a node. highway geometry nodes have no tags
    // so these can be ignored.
    if (way == 0) {
      return;
    }
    // There are always only two entries, the first one is the tag name,
    // the second the tag value.
    auto key = attributes.at(0).value;
    auto value = attributes.at(1).value;
    way->addTag(key, value);
  }
}

void
XML_Parser::on_end_element(const std::string& name)
{
  if (name == "osm" || name == "bounds") {
    return;
  }
  // These can be ignored as the data is grabbed at the start
  // if (name != "node") {
  //     BOOST_LOG_TRIVIAL(debug) << "::on_end_element(node) called: " << name;
  // }
  // if (name != "nd") {
  //     BOOST_LOG_TRIVIAL(debug) << "::on_end_element(nd) called: " << name;
  // }
  // if (name != "tag") {
  //     BOOST_LOG_TRIVIAL(debug) << "::on_end_element(tag) called: " << name;
  // }
  if (name == "way") {
    // Create a spatial geometry from the refs for clipping purposes later
    for (auto it : way->refs) {
      auto node = node_cache.at(it);
      // BOOST_LOG_TRIVIAL(debug) << "::on_end_element(way) called: " << boost::geometry::wkt(node.getPoint());
      boost::geometry::append(way->linestring, node.getPoint());
    }
    // way->dump();
    // way_cache[way->id] = way;
    BOOST_LOG_TRIVIAL(debug) << *way->as_osmxml();
    BOOST_LOG_TRIVIAL(debug) << *way->as_geojson();
  }
}

// void
// XML_Parser::on_characters(const std::string& text)
// {
//   BOOST_LOG_TRIVIAL(debug) << "on_characters(): " << text;
// }

void
XML_Parser::on_comment(const std::string& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_comment(): " << text;
}

void
XML_Parser::on_warning(const std::string& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_warning(): " << text;
}
void
XML_Parser::on_error(const std::string& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_error(): " << text;
}

void
XML_Parser::on_fatal_error(const std::string& text)
{
  BOOST_LOG_TRIVIAL(debug) << "on_fatal_error(): " << text;
}

bool
XML_Parser::readXML(std::istream &xml)
{
 #ifdef TIMING_DEBUG
  boost::timer::auto_cpu_timer timer("XML_Parser::readXML: took %w seconds\n");
#endif

  setlocale(LC_NUMERIC, "C");
  std::ofstream myfile;

  // libxml calls on_element_start for each node, using a SAX parser,
  // and works well for large files.
  try {
    set_substitute_entities(true);
    parse_stream(xml);
  } catch (const xmlpp::exception &ex) {
    // FIXME: files downloaded seem to be missing a trailing \n,
    // so produce an error, but we can ignore this as the file is
    // processed correctly.
    BOOST_LOG_TRIVIAL(error) << "libxml++ exception: " << ex.what();
    // log_debug(xml.rdbuf());
    int return_code = EXIT_FAILURE;
  }

  return true;
}

} // end of osmxml namespace
 
// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
