//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <boost/program_options.hpp>
#include <boost/log/core/core.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/file.hpp>
#include <filesystem>
// #include <dejagnu.h>

namespace logging = boost::log;
using namespace boost;
namespace opts = boost::program_options;

#include "libosm.hh"

int
main(int argc, char *argv[])
{
  opts::positional_options_description p;
  opts::variables_map vm;
  opts::options_description desc("Allowed options");

  logging::add_file_log("libosm.log");
  try {
    // clang-format off
    desc.add_options()
      ("help,h", "display help")
      ("verbose,v", "Enable verbosity")
      ("infile,i", opts::value<std::string>(), "Input data file"
       "The file to be processed")
      ("filter,f", opts::value<std::string>(), "Tag Filter"
       "a tag to filter for")
      ("clip,c", opts::value<std::string>(), "Clip data"
       "Clip data by a MultiPolygon")
      ("outfile,o", opts::value<std::string>(), "Output data file");

    opts::store(opts::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
    opts::notify(vm);
    if (argc == 1) {
      std::cout << "Usage: options_description [options]" << std::endl;
      std::cout << desc << std::endl;
      exit(0);
    }
    if (vm.count("help")) {
      std::cout << "Usage: options_description [options]" << std::endl;
      std::cout << desc << std::endl;
      exit(0);
    }
  } catch (std::exception &e) {
    std::cout << e.what() << std::endl;
    return 1;
  }

  opts::store(opts::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
  opts::notify(vm);

  // Input data in OSM XML or PBF format
  if (! vm.count("infile")) {
    std::cout << "Usage: options_description [options]" << std::endl;
    std::cout << desc << std::endl;
    exit(0);
  }
  std::filesystem::path infile(vm["infile"].as<std::string>());

  // Output file, default to the same format as the input file
  std::string outfile("testout");
  outfile += infile.extension();
  if (! vm.count("infile")) {
    outfile = vm["outfile"].as<std::string>();
  }

  // By default only display informational messages
  logging::core::get()->set_filter(logging::trivial::severity >= logging::trivial::info);

  if (vm.count("verbose")) {
    // Display debugging messages
    logging::core::get()->set_filter(logging::trivial::severity >= logging::trivial::debug);
    logging::add_console_log(std::cout, boost::log::keywords::format = ">> %Message%");
  }


  std::string filter;
  if (vm.count("filter")) {
    filter = vm["filter"].as<std::string>();
  }

  auto aoi = geojson::GeoJson();
  aoi.setupNodeCache("node_cache.db");
  std::string clip;
  multipolygon_t mpoly;
  if (vm.count("clip")) {
    auto data = aoi.readAOI(vm["clip"].as<std::string>());
    mpoly = *data;
  }

  if (infile.extension() == ".osm") {
    auto dparser = osmxml::XML_Parser();
    auto xml = osmxml::XML_Parser();
    std::ifstream indata;
    indata.open(infile, std::ifstream::in);
    if (filter.size() > 0) {
      dparser.addTagFilter(filter);
    }
    if (clip.size() > 0) {
      //dparser.addAOI(clip);
    }
    dparser.readXML(indata);
    // dparser.writeData("foo.osm");
    // BOOST_LOG_TRIVIAL(info) << "Wrote " << outfile;
  } else if (infile.extension() == ".pbf") {
    auto dparser = PBF_Parser();
    if (filter.size() > 0) {
      dparser.addTagFilter(filter);
    }
    if (mpoly.size() > 0) {
      dparser.addAOI(mpoly);
    }
    read_osm_pbf(infile, dparser);
    // dparser.writeData("bar.osm");
  } else if (infile.extension() == ".geojson") {
    auto dparser = geojson::GeoJson();
    // FIXME: in progress...
    // FIXME: This uses a DOM parser, so the entire file is loaded
    // into memory.
    if (filter.size() > 0) {
      dparser.addTagFilter(filter);
    }
    if (mpoly.size() > 0) {
      //dparser.addAOI(clip);
    }
    auto boundary = dparser.readFile(infile);
    // std::cout << boost::geometry::wkt(*result) << std::endl;
    if (boundary.kind() != json::kind::object) {
      BOOST_LOG_TRIVIAL(error) << "Invalid input file!";
      exit(-1);
    }
    auto ftype = boundary.at("type");
    auto gen = boundary.at("generator");
    auto features = boundary.at("features").get_array();
    for (auto it = features.begin(); it!= features.end(); ++it) {
      dparser.makeFeature(*it);
    }
    // dparser.writeCache("bar.osm");
  } else {
    BOOST_LOG_TRIVIAL(error) << "Must be an OSM XML or PBF file!";
  }
}

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
