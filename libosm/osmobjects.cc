//
// Copyright (c) 2024, 2025 OpenStreetMap US
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <string>
#include <vector>
#include <array>
#include <memory>
#include <iostream>
#include <boost/log/trivial.hpp>
#include <boost/date_time.hpp>
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/local_time/local_time.hpp>
#include <boost/date_time/gregorian/gregorian.hpp>

using namespace boost::posix_time;
using namespace boost::gregorian;
using namespace boost::local_time;
#define BOOST_BIND_GLOBAL_PLACEHOLDERS 1

#include "osmobjects.hh"

namespace osmobjects {

std::shared_ptr<std::string>
OsmNode::as_osmxml() const
{
  std::string attributes("<node id=\"%1%\" version=\"%2%\" timestamp=\"%3%\" lat=\"%4%\" lon=\"%5%\"/>");
  std::string timestring = to_iso_extended_string(timestamp);
  timestring += "Z";
  auto xmlout = boost::format(attributes) % id % version % timestring % point.get<1>() % point.get<0>();

  return std::make_shared<std::string>(xmlout.str());
}

std::shared_ptr<std::string>
OsmNode::as_geojson() const
{
  // GeoJson doesn't have nodes, the points are part of the geometry
  // or the OSM way.
#if 0
  bool pretty = "\n";
  // Process the attributes first
  std::string attributes("\"type\": \"Feature\",\n\t \"properties\": {\n\t\t\"id\": \"%1%\",\n\t\t\"version\": \"%2%\"\n\t}\n}");
  auto jsonout = boost::format(attributes) % id % version;
  BOOST_LOG_TRIVIAL(debug) << boost::geometry::wkt(point);

#endif
  return std::make_shared<std::string>();
}

void
OsmObject::dump(void) const
{
   BOOST_LOG_TRIVIAL(debug) << "Dumping OsmObject()";
    if (action == create) {
       BOOST_LOG_TRIVIAL(debug) << "\tAction: Create";
    } else if (action == modify) {
       BOOST_LOG_TRIVIAL(debug) << "\tAction: Modify";
    } else if (action == remove) {
       BOOST_LOG_TRIVIAL(debug) << "\tAction: Delete";
    }

    if (type == node) {
       BOOST_LOG_TRIVIAL(debug) << "\tType: OsmNode";
    } else if (type == way) {
       BOOST_LOG_TRIVIAL(debug) << "\tType: OsmWay";
    } else if (type == relation) {
       BOOST_LOG_TRIVIAL(debug) << "\tType: OsmRelation";
    }
   BOOST_LOG_TRIVIAL(debug) << "\tID: " << std::to_string(id);
   BOOST_LOG_TRIVIAL(debug) << "\tVersion: " << std::to_string(version);
   BOOST_LOG_TRIVIAL(debug) << "\tTimestamp: " << to_simple_string(timestamp);
   if (attributes.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tAttributes: " << attributes.size();
        for (auto it = std::begin(attributes); it != std::end(attributes); ++it) {
           BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->first << ": " << it->second;
        }
    }

    if (tags.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tTags: " << tags.size();
        for (auto it = std::begin(tags); it != std::end(tags); ++it) {
           BOOST_LOG_TRIVIAL(debug) << "\t\t" << it->first << ": " << it->second;
        }
    }
};

void
OsmWay::dump(void) const
{
    OsmObject::dump();
    if (refs.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tRefs: " << refs.size();
        std::string tmp;
        for (auto it = std::begin(refs); it != std::end(refs); ++it) {
            tmp += std::to_string(*it) + ", ";
        }
        tmp.pop_back();
        tmp.pop_back();
       BOOST_LOG_TRIVIAL(debug) << "\t" << tmp;
    }
   BOOST_LOG_TRIVIAL(debug) << boost::geometry::wkt(linestring);
   BOOST_LOG_TRIVIAL(debug) << boost::geometry::wkt(polygon);
    if (tags.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tTags: " << tags.size();
        for (auto const& [key, val] : tags)
        {
           BOOST_LOG_TRIVIAL(debug) << key
                    << ": "
                    << val
                    << ", ";
        }
    } else {
       BOOST_LOG_TRIVIAL(debug) << "No tags.";
    }
};

std::shared_ptr<std::string>
OsmWay::as_osmxml() const
{
  auto out = std::make_shared<std::string>();
  // std::string attributes("id=\"%1%\" lat=\"%2%\" lon=\"%3%\" version=\"%4%\" timestamp=\"%5%\">");
  std::string attributes("<way id=\"%1%\" version=\"%2%\" timestamp=\"%3%\">");
  std::string timestring = to_iso_extended_string(timestamp);
  timestring += "Z";

  auto attrs = boost::format(attributes) % id % version % timestring;
  *out += attrs.str();

  std::vector<std::string> waytags;
  std::string ndfmt("\n\t<nd ref=\"%1%\"/>");
  for (auto it = std::begin(refs); it != std::end(refs); ++it) {
    auto nd = boost::format(ndfmt) % *it;
    *out += nd.str();
  }
  std::string tagfmt("\n\t<tag k=\"%1%\" v=\"%2%\"/>");
  for (auto it = std::begin(tags); it != std::end(tags); ++it) {
    auto tag = boost::format(tagfmt) % it->first % it->second;
    *out += tag.str();
  }
  *out += "\n  </way>";

  return out;
}

std::shared_ptr<std::string>
OsmWay::as_geojson() const
{
    auto out = std::make_shared<std::string>();

    std::string attributes("\ttype\": \"Feature\",\n\t \"properties\": {\n\t\t\"id\": \"%1%\",\n\t\t\"version\": \"%2%\"\n");
    auto jsonout = boost::format(attributes) % id % version;
    //  BOOST_LOG_TRIVIAL(debug) << boost::geometry::wkt(jsonout.str());
    *out += jsonout.str();
    std::string propfmt("\t\t\"%1%\": \"%2%\"\n");
    for (auto it = std::begin(tags); it != std::end(tags); ++it) {
        auto tag = boost::format(propfmt) % it->first % it->second;
        *out += tag.str();
    }
    *out += "\n\t},\n\tgeometry\": {\n\t\t\"type\": \"LineString\".\n\t\t\"coordinates\" [";
    //for (auto it = std::begin(node_cache); it != std::end(node_cache); ++it) {
    // }
    *out += "\n\t\t]\n\t\t]\n\t}\n\t}\n";

    return out;
}

void
OsmRelation::dump() const
{
    OsmObject::dump();
    if (members.size() > 0) {
       BOOST_LOG_TRIVIAL(debug) << "\tMembers: " << members.size();
        std::string tmp;
        for (const auto &member: std::as_const(members)) {
            member.dump();
        }
       BOOST_LOG_TRIVIAL(debug) << "\t" << tmp;
    }
}

void
OsmRelationMember::dump() const
{
   BOOST_LOG_TRIVIAL(debug) << "\t\tDumping Relation member";
   BOOST_LOG_TRIVIAL(debug) << "\t\t\tRef: " << ref;
    if (type == node) {
       BOOST_LOG_TRIVIAL(debug) << "\t\t\tType: OsmNode";
    } else if (type == way) {
       BOOST_LOG_TRIVIAL(debug) << "\t\t\tType: OsmWay";
    } else if (type == relation) {
       BOOST_LOG_TRIVIAL(debug) << "\t\t\tType: OsmRelation";
    }
   BOOST_LOG_TRIVIAL(debug) << "\t\t\tRole: " << role;
}

int
OsmNode::getZ_order() const
{
    return z_order;
}

void
OsmNode::setZ_order(int newZ_order)
{
    z_order = newZ_order;
}

} // namespace osmobjects

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
