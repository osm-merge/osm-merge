//
// Copyright (c) 2025 OpenStreetMap US
//
//     This is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     This project is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "osmconfig.h"
#endif

#include <fstream>
#include <filesystem>
#include <boost/format.hpp>
#include <boost/log/trivial.hpp>

#include "datastore.hh"

// Create a callback function
static int cache_callback(void *NotUsed, int argc, char **argv, char **azColName) {
  long int id = std::stol(argv[0]);
  long int lat = std::stol(argv[1]);
  long int lon = std::stol(argv[2]);
  int version = std::stoi(argv[3]);
  long int timestamp = std::stol(argv[4]);
  BOOST_LOG_TRIVIAL(debug) << "FIXME: " << id << ", " << lat;
  return 0;
}

namespace datastore {

  std::shared_ptr<const OsmNode> DataStore::getNode(long int id) {
    char *zErrMsg = 0;
    std::string sql("SELECT id, lat, lon, version, timestamp");
    auto rc = sqlite3_exec(db, sql.c_str(), cache_callback, 0, &zErrMsg);
    if (rc != SQLITE_OK) {
      BOOST_LOG_TRIVIAL(error) << "SELECT TABLE nodes failed! " << zErrMsg;
    }
  }

  bool
  DataStore::setupNodeCache(const std::string &dbname) {
    char *zErrMsg = 0;
    // Create the table if a new database
    // if (! std::filesystem::exists(dbname)) {
      std::string sql("CREATE TABLE nodes (id bigint PRIMARY KEY NOT NULL, lat double NOT NULL, lon double NOT NULL, version int NOT NULL, timestamp text NOT NULL);");
      // sqlite3_open(dbname.c_str(), &db);
      auto rc = sqlite3_exec(db, sql.c_str(), cache_callback, 0, &zErrMsg);
      if (rc != SQLITE_OK) {
        BOOST_LOG_TRIVIAL(error) << "CREATE TABLE command failed! " << zErrMsg;
      }
      //} else {
      //sqlite3_open(dbname.c_str(), &db);
      //}

    return false;
  }

  void
  DataStore::writeFeature(const OsmWay &way) {
    if (output.size() > 0) {
      for (auto [task, poly] : output) {
	if (boost::geometry::within(way.getLineString(), poly)) {
	  if (keywords.size() > 0) {
	    for (auto key : keywords) {
	      for (auto tag: way.tags) {
	 	if (key == tag.first) {
		  auto data = way.as_osmxml();
		  std::fwrite(data->c_str(), 1, data->size(), task);
		  continue;
		}
	      }
	    }
	  } else {
	    auto data = way.as_osmxml();
	    std::fwrite(data->c_str(), 1, data->size(), task);
	  }
	}
      }
    }
  }

  void
  DataStore::writeFeature(const OsmNode &node) {
#if 0
    if (output.size() > 0) {
      for (auto poly : output) {
	if (boost::geometry::within(node.getPoint(), poly)) {
	  BOOST_LOG_TRIVIAL(debug) << "Node " << " is within the AOI";
	} else {
	  BOOST_LOG_TRIVIAL(debug) << "Node " << " is not within the AOI";
	}
      }
    }
#endif
  }

  void
  DataStore::openOutfiles(const std::string &format) {
    std::filesystem::path path(format);
    int task = 0;
    for (auto it : aoi) {
      auto outfile = boost::format(format) % task++ % suffix;
      struct outfiles ofile;
      ofile.file = std::fopen(outfile.str().c_str(), "w");
      std::cerr  << outfile << std::endl;
      ofile.boundary = it;
      output.push_back(ofile);
      if (suffix == "osm") {
	std::string header = "<?xml version='1.0' encoding='UTF-8'?>\n";
	std::fwrite(header.c_str(), 1, header.size(), ofile.file);
	header = "<osm version=\"0.6\" generator=\"osm-merge\">\n";
	std::fwrite(header.c_str(), 1, header.size(), ofile.file);
      }
    }
  }

  /// Make this the AOI for the next input file
  void
  DataStore::addAOI(const multipolygon_t &mpoly) {
    aoi = mpoly;
    openOutfiles("Task_%1%.%2%");
  }

  void
  DataStore::writeCache(const std::string &outfile) {
    std::ofstream out(outfile);
    std::filesystem::path path(outfile);
    if (path.extension() == ".osm") {
      out << "<?xml version='1.0' encoding='UTF-8'?>" << std::endl;
      out << "<osm version=\"0.6\" generator=\"osm-merge\">" << std::endl;
      for (auto it : node_cache) {
	out << "  " << it.second.as_osmxml() << std::endl;
      }
      for (auto it : way_cache) {
	out << "  " << it.second->as_osmxml() << std::endl;
      }
      out << "</osm>" << std::endl;
    } else if (path.extension() == ".geojson") {
      for (auto it : node_cache) {
	out << "  " << it.second.as_geojson() << std::endl;
      }
      for (auto it : way_cache) {
	out << "  " << it.second->as_geojson() << std::endl;
      }
    }
    out.close();
  }

} // end of datastore

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
